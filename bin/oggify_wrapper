#!/usr/bin/env python

# oggify_wrapper -- Wrapper for bad codecs for Oggify
# Copyright (c) 2008 Scott Paul Robertson (spr@scottr.org)
#
# This is part of Oggify (http://scottr.org/oggify/)
#
# Oggify is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version
# 
# Oggify is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Oggify; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

import sys, os, tempfile, signal, optparse, subprocess

tmpfile = None

def handler(signum=0, frame=None):
    if tmpfile != None:
        os.unlink(tmpfile)
    sys.exit(-1)

def main(argv=sys.argv):
    usage = "%prog {-d|-e} [options] <command>"
    parser = optparse.OptionParser(usage=usage)
    parser.add_option("-d", action="store_true", dest="decode")
    parser.add_option("-e", action="store_false", dest="decode")
    parser.add_option("-s", dest="extension", default='')
    options, args = parser.parse_args()


    if len(args) == 1:
        args = args[0].split()

    for i in xrange(len(args)):
        if args[i] == '%i' or args[i] == '%o':
            fd, tmpfile = tempfile.mkstemp(suffix=options.extension)
            os.close(fd)
            args[i] = tmpfile

    if options.decode:
        os.unlink(tmpfile)
        task = subprocess.Popen(args)
        task.wait()
        if task.returncode != 0:
            return 1
        f = open(tmpfile, 'rb')
        sys.stdout.write(f.read())
        f.close()
        sys.stdout.flush()
    else:
        f = open(tmpfile, 'wb')
        f.write(sys.stdin.read())
        f.flush()
        f.close()
        task = subprocess.Popen(args)
        task.wait()
        if task.returncode != 0:
            return 1

    return 0

if __name__ == '__main__':
    signal.signal(signal.SIGINT, handler)
    signal.signal(signal.SIGHUP, handler)
    signal.signal(signal.SIGTERM, handler)
    return_code = main()
    if tmpfile != None:
        os.unlink(tmpfile)
    sys.exit(return_code)
